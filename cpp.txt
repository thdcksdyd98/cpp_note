1. 
함수를 정의할때 헤더파일에 forward declaration 을 하고 함수의 definition 따로 cpp파일로.
그리고 함수를 사용하는거는 main.cpp에서… -> 이게 정석이기는 한데, 헤더 파일에 definition까지 들어가 있는경우가 많음. 그럴때 헤더가드가 꼭 있어야함. (#pragma once)

2. 
initialization할때는 {}을 사용하는것이 클래스 사용할때에도 좋음 -> type에 문제가 있으면 warning보다는 compile이 안되게 막아줌. 

3. 
			(type)		(at least)
character 	char 		1 byte (8 bits)
integer 	short		2 byte (16 bits)
integer		int 		2 byte (16 bits) (mostly 4 byte)
integer 	long 		4 byte (32 bits)
integer		long long 	8 byte (64 bits)
floating	float 		4 byte (32 bits)
floating 	double		8 byte (64 bits)
floating	long double	8 byte (64 bits) (mostly 8, 12, or 16 byte depending on OS or compiler)

#include <limits>
#include <iosream>

numeric_limits<"TYPE">::max() 		-> the hightest number (absolute number) that "TYPE" can represent
numeric_limits<"TYPE">::min() 		-> the lowest number (absolute number) that "TYPE" can represent
numeric_limits<"TYPE">::lowest() 	-> the actual number that "TYPE" can represent (for floating type,  min() does not show negative value but lowest() does)

for float initialization, should add 'f' at the end of literal; modern c/c++'s default is double


#include <iomanip>
#include <iostream>
cout << std::setprecision(16)	-> show 16 digits after decimal points; it modify decimal precision after this line by converting number as binary internally.

#include <cmath>
#include <iostream>
std::isnan("VALUE")	-> return true/false
std::isinf("VALUE") -> return true/false

** inf != NaN **

4. 
float = 32 bits
1 for sign
8 for exponent
23 for mantissa

if)
sign = 0
exponent = 7
mantissa = 0.75
=> +(1+0.75)*2^(7-127) = +1.316554 * 10^-36

why 1 + 0.75?
IEEE 754 normalized form. if exponent is not 0, then mantissa is always following 1.xxxx form.
(since exponent is always based on '2' -> [1,2), so if 2.xxxx then exponent should be added 1 and keep 1)

why 7 - 127?
-127 is added for 'bias' (considering negative exponent)
having negative exponent means moving 'k' binary decmial point toward left
1.011(2) * 2^-2 = 0.01011(2)

if exponent 'e' is 1~254 ( excluding 0 and 255, which is not acceptable in float type), then it is 'normal'.
E = e - 127

if exponent 'e' = 0 and mantissa is not equal to 0, then it is 'subnormal'

if exponent 'e' = 255 and if mantissa is 0 than, it is +- infinit. if mantissa is not 0 then NaN.

5.

#include <iostream>

1/0 -> true/false
std::boolalpha

true/false -> 1/0
std::noboolalpha

6.

type casting => 

#include <iostream>
static_cast<"TYPE">("VALUE")

7. 
header: 선언을 담은 소스 조각. #include로 컴파일러가 타입 체크하고 템플릿 인스턴스 등을 만들 수 있게함.
library: 이미 컴파일된 기계어 정의의 묶음. 링커가 심볼을 결합할 때 필요.

static_cast<>()는 연산자임. 

함수형 vs 명시적 캐스트:
char("VALUE") => functional cast
static_cast<"TYPE">("VALUE") => keyword cast

결과가 동일하고 오버헤드가 없음. 다만 스타일/가독성과 클래스 타입에서 차이점이 존재.

a) keyword cast는 의도적으로 형변환한다 라는것을 분명하게 보여줄수 있음. functional cast는 생성자 호출처럼 보일 수 있는 여지가 있음.
b) functional cast는 생성자 호출 규칙(오버로드 해석)을 따르고, keyword cast는 정적 캐스트 규칙을 따름.

keyword cast는 컴파일 단계에서 변환된 타입에 문제가 없는지 확인. functional cast는 좀 널널한편


header에 여러 namespace가 있는데 대부분 std가 있음.

8.
\n vs endl
\n은 단순 줄바꿈
endl는 버퍼에 있는 모든 문자들을 모두 비워냄 (출력함).

std::flush -> 줄바꿈을 하지 않고 버퍼에 있는 모든 문자들을 모두 비워냄

9.
리터럴 앞에 0은 8진수 0x는 16진수 
0b는 2진수 (c++ 14부터)

10. 
함수의 파라미터값에 const 상수를 사용하수 있음. 이유는 함수 안에서 파라미터로 받은 값이 변경이 된다면, 사실상 함수 입출력이 
명확해 지지 못하는 단점이 있기 때문. 따라서 개발자가 const상수를 파라미터로 고정해 다른 함수 안에서 값의 변경을 막을수가 있음


11.
컴파일 상수 vs 런타임 상수
상수의 값이 컴파일에 결정이 되는지, 런타임에 결정이 되는지에 따라 달라짐.
컴파일 상수는 constexpr으로 (c++ 11 이상) 명시적으로 표현해줄수 있음
 
12.
상수를 따로 모아서 헤더파일에 넣어서 사용하는게 좋음

ex)
#pragma once
namespace constants{
	constexpr double pi{3.141592};
	constexpr double avogadro{6.0221413e23};
	....
}

...

#include "CONSTANTS.h" -> 메인에서 이렇게 사용


13.
a++ vs ++a의 차이점을 알아야함.

int a = 4;
cout << a++ << endl; // 출력은 4 (a를 먼저 출력후 1을 더함)

int a = 4;
cout << ++a << endl; // 출력은 5 (1을 먼저 더한다음 a를 출력)


14.
comma operator

int a = (b,c) // 처음 b값이 a로, 그다음 c값이 다시 a로.

int a = b,c // b값이 a로. c는 아무것도 안함.


conditional operator (arithmetric if)

bool onSale = true;
const int price = (onSale == true) ? 10 : 100; // 상수값을 조건에 따라서 선언할수 있음

/*
if (onSale)
	price = 10;
else
	price = 100;
*/
와 같음

15. 

short circuit evaluation

int x = 2;
int y = 2;
if (x == 1 && y++ == 2)
{
	// do something
}
// 2 => && operator는 처음 x == 1의 값을 evaluate할때 False이면 우측의 계산을 하지 않음
// 즉, x == 1 (False), skip operation y++ == 2
cout << y << endl;

16.

logical AND 가 logical OR보다 우선순위가 높음

bool r1 = v1 || v2 && v3;
bool r3 = v1 || (v2 && v3);
r1이 계산되는 순서는 r3와 동일

17.
음의 부호 이진수
	a) 맨 앞자리는 +/-를 표현
	b) 십진수 음의 정수를 이진수로 표현할때
		i) 절대값을 이진수로 변경
		ii) 보수 (complement)를 취해줌
		iii) 이진수 1을 더해줌
				-> 왜 1을 더해주는가? => +0/-0가 동시에 존재해서

18.
bitwise operator

<< left shift
>> right shift

(cout/cin에서 사용되는 거와 모양은 같지만 다른 의미)

~ bitwise not
& bitwise and
| bitwise or
^ bitwise xor

bitwise연산에는 unsigned를 사용하는게 일반적

#include <iostream>
#include <bitset> // 2진수의 표현으로 보여줌

int main() {
	using namespace std;

	unsigned int a = 3;
	cout << std::bitset<4>(a) << endl; // a변수의 값을 2진수로 4비트를 사용해서 0011 (10진수로는 3)

	unsigned int b = a << 1; // left 방향으로 한칸 shift 0110 (10진수로는 6)
	cout << std::bitset<4>(b) << endl; 


	/*
		left shift하면 2의 제곱수를 곱하는것. 한번 shift는 2^1, 두번은 2^2, 세번은 2^3 .... 
		rifht shift하면 역으로 2의 제곱수를 나누는것. 
	*/

	cout << std::bitset<4>(~a) << endl; // 이진수 a의 값의 not (보수)를 취해주는것 1100

	// 참고: 변수를 이진수로 표현하고 싶으면 0b를 사용하면됨.

	unsigned int a = 0b1100;
	unsigned int b = 0b0110;

	cout << std::bitset<4>(a & b) << endl; // 0100
	cout << std::bitset<4>(a | b) << endl; // 1110
	cout << std::bitset<4>(a ^ b) << endl; // 1010

	// 참고: bitwise operator도 줄여쓰는것이 가능함 a &= b; a |= b; a ^= b;

	/*

	0110 >> 2을 하게 되면 0001 칸을 넘어가면 skip이 되는 구조.
	*/

	return 0;

}

19.

bit flags

bool은 1byte, 즉 8비트의 공간을 가지고 있음. 근데 여기에 1/0의 값만 가지고 있음. 
다른 bool형식의 변수들을 하나씩 선언하는거 보다, 하냐의 bool자료형에 남는 7비트의 공간을 잘 활용할수 있을것이라는것에서 부터 시작되었음.


int main() {
	const unsigned char opt0 = 1 << 0; // 0000 0001
	const unsigned char opt1 = 1 << 1; // 0000 0010
	const unsigned char opt2 = 1 << 2; // 0000 0100
	const unsigned char opt3 = 1 << 3; // 0000 1000
	// opt4,5,6,7

	unsigned char items_flag = 0;
	cout << "No Item " << bitset<8>(items_flag) << endl; // 0000 0000

	// item0 on
	items_flag |= opt0;
	cout << "Item0 Obtained " << bitset<8>(items_flag) << endl; // 0000 0001

	// item3 on
	items_flag |= opt3;
	cout << "Item3 Obtained " << bitset<8>(items_flag) << endl; // 0000 1001

	// item3 lost
	items_flag &= ~opt3;
	cout << "Item3 Lost " << bitset<8>(items_flag) << endl; // 0000 0001

	// has item1 ? 
	if(items_flag & opt1) {cout << "has item1" << endl;}
	else {cout << "not has item1" << endl;} // not have item1

	// has item0 ?
	if(items_flag & opt0) {cout << "has item0" << endl;} // has item0

	// obtain item 2,3
	items_flag |= (opt2 | opt3);
	cout << bitset<8>(opt2 | opt3) << endl; // 0000 1100
	cout << "Item2,3 obtained " << bitset<8>(items_flag) << endl; // item2,3 obtained 0000 1101


	if ((items_flag & opt2) && !(items_flag & opt1))
	{
		// xor (^)는 반전시켜줌
		items_flag ^= opt2; 
		items_flag ^= opt1;

	}

	return 0;
}

20.

bit masks

int main() {

	const unsigned int red_mask = 0xFF0000;
	const unsigned int green_mask = 0x00FF00;
	const unsigned int blue_mask = 0x0000FF;

	unsigned int pixel_color = 0xDAA520; (0x00DAA520과 같음)

	cout << std::bitset<32>(pixel_color) << endl;

	unsigned char blue  = pixel_color & blue_mask;
	// 이렇게 하면 pixel_color의 16진수 형태의 값에서 RGB의 B의 부분만 추출함.

	unsigned char green  = (pixel_color & blue_mask) >> 8; // char은 8bit밖에 못보여주니까 값을 제대로 보여줄수 없음. 그래서 shift를 함.
	
	return 0;        
}

21.

local variable

int main() {
	using namespace std;

	int apple = 5;

	cout << apple << endl;

	{
		int apple = 1;			// 이 스코프 안에서만 유효. int type의 새로운 메모리 공간을 사용, 즉 apple = 1. bracket이 끝나면 이 변수는 사라짐. (name hiding)
		cout << apple << endl;
	}
	cout << apple << end;
}


int main() {
	using namespace std;
	int apple = 5;

	cout << apple << endl;

	{ 
		apple = 1;				// bracket으로 scope를 정의해 줘도, 새로운 메모리 공간을 할당받는게 아닌, 위에 정의한 apple을 사용. 따라서 apple = 5
		cout << apple << endl;
	}

	cout << apple << endl;
}

22.

namespace

이름과 return type이 같은 함수 2개를 정의한다고 하자.

namespace function1
{
	int a = 1;
	void doSomething(){
		//do something
	}
}

namespace function2
{
	int a = 1;
	void doSomething(){
		// do something
	}
}

int main(){
	function1::a;
	function1::doSomething();

	function2::a;
	function2::doSomething();

	return 0;
}

이렇게 namespace별로 나눠서 사용할수 있음.
C17부터 nested namespace가 가능해짐.

아래처럼 하나로 nested namespace도 가능함. 다만 권장하지는 않음.

namespace work1::work11::work111
{
	int a = 1;
	void doSomething()
	{
		a += 3;
	}
}

23.
 































