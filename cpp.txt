1. array 2

#include <iostream>
#define NUM_STUDENT 100000
using namespace std;

void doSomething(int students_scores[20])
{
	// do something
	cout << (int)&students_scores << endl; // 매개변수
}

int main()
{
	const int num_students = 20;

	int students_score[num_students] = {1,2,3,4,5,};

	doSomething(students_scores);
	/*

	array를 함수에 인자로 넣으면 array의 주소값, 즉 &students_score[0]가 parameter로 들어가게됨.
	일반 값을 인자로 넣으면 값이 복사가 되는것과는 다름.
	doSomething함수에서 안에서 사용되는 매개변수는 결국 포인터 변수이기 때문에 main에 있는 array와 주소값이 달라질수밖에 없음.

	만약 doSomething함수에서 array의 첫번째 원소의 주소 (int)&students_scores[0]을 출력한다면, 이는 main의 students_scores의 배열의 주소와 같은 값을 가지게 될것.
	(int)&students_scores != (int)&studens_scores[0]
	전자는 포인터 변수이고 후자는 포인터 변수가 가르키는 array의 첫번째 원소의 주소. 즉 원본의 주소값과 같음.

	doSomething함수에서 인자로 받는 array의 크기를 정의해주지 않아도 상관없음. 결국 포인터변수이기 때문에.
	*/
}

2. 배열과 반복문

#include <iostream>
using namespace std;

int main() 
{
	const int num_students = 5;
	int score0 = 84;
	int score1 = 92;
	int score2 = 76;
	int score3 = 81;
	int score4 = 56;

	int total_score = score0 + score1 + score2 + score3 + score4
	double avg_score = static_cast<double>(total_score) / num_students;

	// 형변환을 나누기전에 하는것과 나누고 나서 하는것의 차이가 있을수가 있음. 따라서 나누기 전에 캐스팅 하는것을 추천.
}

위 방법은 효율적이지 못함

int main()
{
	int scores[] = {84,9276,81,56};
	const int num_students = sizeof(scores) / sizeof(int);
	int max_score = 0;
	int total_score = 0;

	for (int i = 0; i < num_students; ++i)
	{
		max_score = (score[i]>max_score)?score[i]:max_score;
		total_score += scores[i];
	}
	double avg_score = static_cast<double>(total_score) / num_students;
}
훨 간편함.

3. 배열과 선택정렬 (selection sort)
선택 정렬은 첫 인덱스 값부터 시작해 그 이후에 있는 원소들을 비교, 가장 작은값을 찾아서 현재 값 (첫 인덱스)과 스왑.
idx+1에서 다시 비교를 시작. 똑같이 idx+1 이후에 있는 원소들을 비교해서 가장 작은값을 찾고 스왑. 

#include <iostream>
using namespace std;

void printArray(int array[], int length) {
    for (int i = 0; i < length; ++i) {
        cout << array[i] << " ";
    }
    cout << endl;
}
int main() {

    int array[] = {3,5,2,7,1,4,6};
    const int length = (sizeof(array) / sizeof(int));
    printArray(array, length);
    for (int s_index=0; s_index<length-1; ++s_index) {
        int t_index = s_index;
        for (int c_index=s_index+1; c_index<length; ++c_index) {
            t_index = (array[t_index]<array[c_index])?t_index:c_index; //
        }
        // swap values
        {
            int tmp = array[s_index];
            array[s_index] = array[t_index];
            array[t_index] = tmp;
        }
        printArray(array, length);
    }
    return 0;
}

4. 정적 다차원 배열 (multi-dimensional array)


int main()
{
	const int num_rows = 3;
	const int num_columns = 5;

	// 다차원 배열 초기화
	int array[num_rows][num_columns] = 		// num_rows는 컴파일러가 갯수를 셀수 있기때문에 생략 가능; row에 비어있는 부분이 있다면 0으로 초기화 자동. 
	{
		{1, 2, 3, 4, 5}, 		// row 0
		{6, 7, 8, 9, 10}, 		// row 1
		{11, 12, 13, 14, 15}, 	// row 2
	};
	for (int r=0; r<num_rows; ++r){
		for (int c=0; c<num_columns; ++c){
			cout << array[r][c] << '\t';
		}
	}
	cout << endl;
}

/*
array를 컴파일러가 포인터로 처리 (pointer decay).
맥이나 리눅스는 64비트 환경을 사용. 포인터가 8바이트.
int형으로 캐스팅을 진행시 8 -> 4 바이트로 줄어드어 상위 4바이트가 손실이 일어남. 
따라서 맥이나 리눅스환경에서는 

#include <cstdint>에서 uintptr_t를 사용해서 주소값을 int형으로 캐스팅해야함.

cout << (uintptr_t)&array[r][c] << '\t' 이런식으로.
*/


5. C언어 스타일의 배열 문자열
string이전에는 char타입의 배열을 사용해서 문자열을 저장했음. 
모든 문자열은 '\0' (null character)가 포함 되어있는데, 이게 중간에 있으면 그 이전까지는 출력이 되다가 그 이후에는 출력이 되지 않음.
'cstring' 라이브러리가 등장해서 사용하기 편해짐.


#include <cstring>

int main() {
	
	char source[] = "Copy this!";
	char dest[50];

	strcpy_s(dest, 50, source); // string을 source에서 dest로 복사붙여넣기 함. 최대 size를 인수값으로 넣어야함.
	strcat() // 문자열을 붙임
	strcmp() // 두 문자열이 같은지 비교, 같으면 0 리턴 아니면 -1  리턴

	return 0;
}

6. 포인터의 기본적인 사용법

